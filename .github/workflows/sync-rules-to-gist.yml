name: Sync Remote Rules to Gist

on:
  schedule:
    - cron: '10 0 * * *'
  workflow_dispatch:
  push:
    paths:
      - '.github/rules-urls.txt'
    branches:
      - main

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      
      - name: 配置 Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
      
      - name: 克隆 Gist
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.REMOTE_CLASH_RULES_GIST_ID }}
        run: |
          git clone https://${GIST_TOKEN}@gist.github.com/${GIST_ID}.git gist-repo
      
      - name: 下载远程规则文件（智能命名）
        run: |
          CONFIG_FILE=".github/rules-urls.txt"
          
          echo "=========================================="
          echo "🌐 开始下载远程规则文件"
          echo "=========================================="
          echo ""
          
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "❌ 配置文件不存在: $CONFIG_FILE"
            exit 1
          fi
          
          echo "📋 读取配置文件: $CONFIG_FILE"
          echo ""
          
          SUCCESS=0
          FAILED=0
          SKIPPED=0
          
          mkdir -p /tmp/downloaded_rules
          
          # 用于跟踪文件名冲突
          declare -A filename_map
          
          while IFS= read -r line || [ -n "$line" ]; do
            url=$(echo "$line" | xargs)
            
            [[ -z "$url" || "$url" =~ ^# ]] && continue
            
            # 从URL中提取基础文件名
            base_filename=$(basename "$url" | cut -d'?' -f1)
            
            # 从URL中提取路径信息用于区分
            # 例如: geo/geosite/cn.mrs -> geosite-cn.mrs
            #       geo/geoip/cn.mrs -> geoip-cn.mrs
            url_path=$(echo "$url" | sed 's|https\?://[^/]*/||' | sed 's|/[^/]*$||')
            
            # 智能生成文件名
            if [[ "$url_path" =~ geoip ]]; then
              # geoip 文件添加 geoip- 前缀
              final_filename="geoip-${base_filename}"
            elif [[ "$url_path" =~ geosite ]]; then
              # geosite 文件添加 geosite- 前缀
              final_filename="geosite-${base_filename}"
            else
              # 其他文件保持原名
              final_filename="$base_filename"
            fi
            
            # 检查文件名是否已存在
            if [[ -n "${filename_map[$final_filename]}" ]]; then
              echo "⚠️  警告: 文件名冲突 $final_filename"
              echo "   URL1: ${filename_map[$final_filename]}"
              echo "   URL2: $url"
              echo "   将使用计数后缀"
              
              # 添加计数后缀
              count=2
              temp_filename="${final_filename%.*}_${count}.${final_filename##*.}"
              while [[ -n "${filename_map[$temp_filename]}" ]]; do
                count=$((count + 1))
                temp_filename="${final_filename%.*}_${count}.${final_filename##*.}"
              done
              final_filename="$temp_filename"
            fi
            
            # 记录文件名映射
            filename_map[$final_filename]="$url"
            
            echo "📥 下载: $final_filename"
            if [[ "$final_filename" != "$base_filename" ]]; then
              echo "   原名: $base_filename"
            fi
            echo "   URL: $url"
            
            if curl -fsSL -o "/tmp/downloaded_rules/$final_filename" "$url" --connect-timeout 30 --max-time 120; then
              if [ -s "/tmp/downloaded_rules/$final_filename" ]; then
                cp "/tmp/downloaded_rules/$final_filename" "gist-repo/$final_filename"
                size=$(du -h "gist-repo/$final_filename" | cut -f1)
                echo "   ✓ 成功 ($size)"
                SUCCESS=$((SUCCESS + 1))
              else
                echo "   ⚠ 文件为空，跳过"
                rm -f "/tmp/downloaded_rules/$final_filename"
                SKIPPED=$((SKIPPED + 1))
              fi
            else
              echo "   ✗ 下载失败"
              FAILED=$((FAILED + 1))
            fi
            
            echo ""
          done < "$CONFIG_FILE"
          
          echo "=========================================="
          echo "📊 下载统计"
          echo "=========================================="
          echo "  ✓ 成功: $SUCCESS"
          echo "  ✗ 失败: $FAILED"
          echo "  ⚠ 跳过: $SKIPPED"
          echo "=========================================="
      
      - name: 清理 Gist 中的过期文件
        run: |
          CONFIG_FILE=".github/rules-urls.txt"
          
          echo ""
          echo "🗑️  清理 Gist 中的过期文件..."
          echo ""
          
          cd gist-repo
          
          DELETED=0
          
          # 生成预期的文件列表（应用相同的命名规则）
          EXPECTED_FILES=""
          while IFS= read -r line || [ -n "$line" ]; do
            url=$(echo "$line" | xargs)
            [[ -z "$url" || "$url" =~ ^# ]] && continue
            
            base_filename=$(basename "$url" | cut -d'?' -f1)
            url_path=$(echo "$url" | sed 's|https\?://[^/]*/||' | sed 's|/[^/]*$||')
            
            if [[ "$url_path" =~ geoip ]]; then
              final_filename="geoip-${base_filename}"
            elif [[ "$url_path" =~ geosite ]]; then
              final_filename="geosite-${base_filename}"
            else
              final_filename="$base_filename"
            fi
            
            EXPECTED_FILES="${EXPECTED_FILES}${final_filename}"$'\n'
          done < "../$CONFIG_FILE"
          
          # 检查并删除不在列表中的文件
          for gist_file in $(find . -type f -not -path "./.git/*" | sed 's|^\./||'); do
            if ! echo "$EXPECTED_FILES" | grep -qx "$gist_file"; then
              rm -f "$gist_file"
              echo "  ✗ 已删除: $gist_file （未在配置中）"
              DELETED=$((DELETED + 1))
            fi
          done
          
          cd ..
          
          if [ $DELETED -eq 0 ]; then
            echo "  ℹ️  无需删除"
          else
            echo ""
            echo "  📊 共删除 $DELETED 个文件"
          fi
      
      - name: 显示同步结果
        working-directory: ./gist-repo
        run: |
          echo ""
          echo "=========================================="
          echo "📦 Gist 中的规则文件"
          echo "=========================================="
          echo ""
          
          if [ -n "$(ls -A . 2>/dev/null | grep -v '^\.git$')" ]; then
            find . -type f -not -path "./.git/*" | sort | while read file; do
              filename=$(basename "$file")
              size=$(du -h "$file" | cut -f1)
              lines=$(wc -l < "$file" 2>/dev/null || echo "0")
              echo "  📄 $filename"
              echo "     大小: $size | 行数: $lines"
            done
          else
            echo "  (无文件)"
          fi
          
          echo ""
          FILE_COUNT=$(find . -type f -not -path "./.git/*" | wc -l)
          TOTAL_SIZE=$(du -sh . 2>/dev/null | cut -f1)
          
          echo "=========================================="
          echo "📊 统计信息"
          echo "=========================================="
          echo "  文件数量: $FILE_COUNT"
          echo "  总大小: $TOTAL_SIZE"
          echo "=========================================="
      
      - name: 提交更改
        working-directory: ./gist-repo
        run: |
          git add -A
          
          if git diff --staged --quiet; then
            echo ""
            echo "ℹ️  规则文件无变更，跳过推送"
            echo "HAS_CHANGES=false" >> $GITHUB_ENV
          else
            echo ""
            echo "📝 检测到变更，准备提交..."
            
            ADDED=$(git diff --staged --name-only --diff-filter=A | wc -l)
            MODIFIED=$(git diff --staged --name-only --diff-filter=M | wc -l)
            DELETED=$(git diff --staged --name-only --diff-filter=D | wc -l)
            
            git commit -m "Sync: +$ADDED ~$MODIFIED -$DELETED @ $(date -u '+%Y-%m-%d %H:%M')"
            echo "HAS_CHANGES=true" >> $GITHUB_ENV
          fi
      
      - name: 推送到 Gist
        if: env.HAS_CHANGES == 'true'
        working-directory: ./gist-repo
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.REMOTE_CLASH_RULES_GIST_ID }}
        run: |
          git remote set-url origin https://${GIST_TOKEN}@gist.github.com/${GIST_ID}.git
          git pull --rebase origin master 2>/dev/null || git pull --rebase origin main
          git push origin HEAD
          
          echo ""
          echo "=========================================="
          echo "🎉 成功推送到 Gist！"
          echo "=========================================="
          echo ""
          echo "📍 Gist 地址:"
          echo "   https://gist.github.com/${GIST_ID}"
          echo ""
          echo "⏰ 下次自动同步: 明天 0:10 UTC (北京时间 8:10)"
          echo "=========================================="
